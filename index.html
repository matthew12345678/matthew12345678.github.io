<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RNBO Sample Loader + Controls</title>
  <style>
    body { font-family: sans-serif; padding: 2em; }
    canvas { border: 1px solid #ccc; width: 100%; height: 100px; margin-top: 1em; }
    #log { background: #f0f0f0; padding: 1em; margin-top: 2em; font-size: 0.9em; }
    label { display: block; margin-top: 1em; }
  </style>
</head>
<body>
  <h1>Load Audio Sample into RNBO buffer~ kick</h1>

  <input type="file" id="fileInput" accept="audio/*">
  <button id="playBtn">‚ñ∂Ô∏è Play</button>

  <label>
    üîÅ Loop:
    <input type="checkbox" id="loopToggle">
  </label>

  <label>
    üéöÔ∏è Rate:
    <input type="range" id="rateSlider" min="0.1" max="2.0" step="0.01" value="1">
  </label>

  <canvas id="waveform" width="800" height="100"></canvas>
  <div id="log">üìù Log Output:</div>

  <script src="https://cdn.cycling74.com/rnbo/1.3.3/rnbo.min.js"></script>

  <script>
    const logDiv = document.getElementById("log");
    const log = msg => {
      console.log(msg);
      logDiv.innerHTML += `<br>${msg}`;
    };

    window.addEventListener("DOMContentLoaded", async () => {
      log("üì¶ DOMContentLoaded fired.");
      log("RNBO version: " + RNBO.version);

      const fileInput = document.getElementById('fileInput');
      const canvas = document.getElementById('waveform');
      const ctx = canvas.getContext('2d');
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
window.audioContext = audioContext;


      const playBtn = document.getElementById("playBtn");
      const loopToggle = document.getElementById("loopToggle");
      const rateSlider = document.getElementById("rateSlider");

      let device;

      async function setupRNBO() {
        try {
          log("üß† Fetching patch...");
          const res = await fetch("export/patch.export.json");
          if (!res.ok) throw new Error("‚ö†Ô∏è Failed to load patch.export.json");

          const patcher = await res.json();

          log("üéõÔ∏è Creating RNBO device...");
          device = await RNBO.createDevice({ patcher, context: audioContext });
          device.node.connect(audioContext.destination);
window.device = device;
          log("‚úÖ RNBO device is ready.");

console.log("üîç Available parameters:");
console.log([...device.parametersById.keys()]);

          /// üîÅ Loop toggle
loopToggle.addEventListener("change", () => {
  const val = loopToggle.checked ? 1 : 0;
  const loopParam = device.parametersById.get("loop");
  if (loopParam) loopParam.value = val;
  log(`üîÅ loop = ${val}`);
});

          // üéöÔ∏è Rate slider
rateSlider.addEventListener("input", () => {
  const val = parseFloat(rateSlider.value);
  const rateParam = device.parametersById.get("rate");

  if (rateParam) {
    rateParam.value = val;
    // Only log the final value every 200ms (throttle effect)
    clearTimeout(window._rateLogTimer);
    window._rateLogTimer = setTimeout(() => {
      log(`üéöÔ∏è rate = ${rateParam.value.toFixed(2)}`);
    }, 200);
  }
});


         playBtn.addEventListener("click", () => {
  const playParam = device.parametersById.get("play");
  if (playParam) {
    playParam.value = 1;
    setTimeout(() => {
  playParam.value = 0;
}, 50);
 // ‚úÖ CORRECTED with curly braces
    log("‚ñ∂Ô∏è play triggered");
  }
});


        } catch (err) {
          log("‚ùå RNBO setup error: " + err.message);
        }
      }

      fileInput.addEventListener('change', async (evt) => {
        const file = evt.target.files[0];
        if (!file) return log("‚ö†Ô∏è No file selected");

        const reader = new FileReader();
        reader.onload = async () => {
          try {
            await audioContext.resume();
            log("üéµ Decoding audio...");
            const audioBuffer = await audioContext.decodeAudioData(reader.result);
            log("‚úÖ Audio decoded");
            paintBuffer(audioBuffer);
            loadBufferToRNBO("kick", audioBuffer);
          } catch (err) {
            log("‚ùå Audio decode/load error: " + err.message);
          }
        };
        reader.readAsArrayBuffer(file);
      });

      function loadBufferToRNBO(bufferName, audioBuffer) {
        try {
          log(`üì• Setting data buffer "${bufferName}" (${audioBuffer.numberOfChannels}ch, ${audioBuffer.length} samples)`);

          device.setDataBuffer(
            bufferName,
            audioBuffer,
            audioBuffer.numberOfChannels,
            audioBuffer.sampleRate
          );

          log(`‚úÖ Loaded audio into RNBO buffer~ "${bufferName}"`);
        } catch (err) {
          console.error(err);
          log("‚ùå Failed to setDataBuffer: " + err.message);
        }
      }

      function paintBuffer(buffer) {
        const width = canvas.width;
        const height = canvas.height;
        const data = buffer.getChannelData(0);
        const step = Math.ceil(data.length / width);
        const amp = height / 2;

        ctx.clearRect(0, 0, width, height);
        ctx.beginPath();
        for (let i = 0; i < width; i++) {
          const slice = data.slice(i * step, (i + 1) * step);
          const min = Math.min(...slice);
          const max = Math.max(...slice);
          ctx.moveTo(i, (1 + min) * amp);
          ctx.lineTo(i, (1 + max) * amp);
        }
        ctx.strokeStyle = 'black';
        ctx.stroke();
      }

      log("üöÄ Running setupRNBO...");
      await setupRNBO();
    });
  </script>
</body>
</html>
