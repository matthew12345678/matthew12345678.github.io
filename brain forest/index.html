<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wave Modules with Carrier Controls</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #282c34; color: #eee; margin: 0; padding: 20px; }
    .global-controls { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .modules-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }
    .wave-module { background: #1a1d23; padding: 10px; border-radius: 8px; position: relative; }
    .wave-trigger { cursor: pointer; color: #61dafb; font-size: 18px; }
    .settings { display: none; margin-top: 10px; background: #2b2f36; padding: 8px; border-radius: 6px; }
    .control-group { margin-bottom: 8px; }
    .control-group label { color: #61dafb; font-size: 12px; display: block; margin-bottom: 4px; }
    .control-group select, .control-group input { width: 100%; padding: 4px; background: #1a1d23; border: 1px solid #444; border-radius: 4px; color: #eee; font-size: 12px; }
    .external-output { margin-top: 10px; text-align: center; }
    .external-output canvas { width: 100%; height: 50px; background: #282c34; display: block; }
    .value { color: #61dafb; font-family: monospace; margin-top: 4px; }
  </style>
</head>
<body>
  <div class="global-controls">
    <button id="exportBtn">Export All</button>
    <button id="importBtn">Import</button>
    <input type="file" id="importFile" accept="application/json" style="display:none;">
    <div style="margin-left: 10px;">
      <label for="presetSelector">Load Preset:</label>
      <select id="presetSelector" style="padding: 4px; font-size: 12px;">
        <option value="">-- Select a Preset --</option>
      </select>
    </div>
    <label>Wave:</label>
    <select id="carrierType">
      <option value="sine">Sine</option>
      <option value="square">Square</option>
      <option value="sawtooth">Sawtooth</option>
      <option value="reverse-sawtooth">Reverse Saw</option>
      <option value="triangle">Triangle</option>
      <option value="reverse-triangle">Reverse Triangle</option>
    </select>
    <label>Freq:</label><input type="range" id="carrierFreq" min="20" max="2000" value="440" step="1" style="width:120px;"><span id="carrierFreqDisplay" style="width:40px; display:inline-block; text-align:right;">440</span><span>Hz</span>
    <label>Vol:</label><input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.5" style="width:120px;"><span id="masterVolDisplay" style="width:40px; display:inline-block; text-align:right;">0.50</span>
    <span style="margin-left: 5px; border: 1px solid #444; padding: 5px; border-radius: 4px; display: inline-flex; flex-direction: column; align-items: flex-start; vertical-align: middle;">
      <label for="midiInSelectMasterVol" style="font-size:12px; margin-bottom:2px;">MIDI In:</label>
      <select id="midiInSelectMasterVol" style="width: auto; margin-bottom: 5px; font-size:12px; padding: 2px;">
        <option value="">-- no device --</option>
      </select>
      <button id="learnBtnMasterVol" style="padding: 4px 8px; font-size: 12px; margin-top: 2px;">MIDI Learn</button>
      <div id="statusMasterVol" style="margin-top: 3px; font-size: 11px; color: #aaa;">CC: -- | Value: 0.50</div>
    </span>
    <label>Detune:</label><input type="range" id="detune" min="-100" max="100" step="1" value="0">
    <label>Pan:</label><input type="range" id="pan" min="-1" max="1" step="0.01" value="0">
    <label>Test:</label><input type="range" id="testSlider" min="-7" max="1" step="0.01" value="0" style="width:120px;"><span id="testSliderDisplay" style="width:50px; display:inline-block; text-align:right;">0.00</span>
    <label>Test2:</label><input type="range" id="test2Slider" min="-7" max="1" step="0.01" value="0" style="width:120px;"><span id="test2SliderDisplay" style="width:50px; display:inline-block; text-align:right;">0.00</span>
  </div>

  <div class="modules-container" id="modulesContainer"></div>

  <!-- Added Filter and Reverb Controls -->
  <div class="control-group" style="margin-top: 30px; padding: 15px; border: 1px solid #555; border-radius: 8px;">
    <h2>Effects Section</h2>
    
    <!-- Filter Controls -->
    <div style="margin-bottom: 20px; padding-bottom:15px; border-bottom: 1px solid #444;">
      <h3>Filter</h3>
      <div class="control-group">
        <label for="effectFilterType">Filter Type:</label>
        <select id="effectFilterType" style="width: auto;">
          <option value="lowpass">Low-pass</option>
          <option value="highpass">High-pass</option>
          <option value="bandpass">Band-pass</option>
          <option value="lowshelf">Low-shelf</option>
          <option value="highshelf">High-shelf</option>
          <option value="peaking">Peaking</option>
          <option value="notch">Notch</option>
          <option value="allpass">All-pass</option>
        </select>
      </div>
      <div class="control-group">
        <label for="effectFilterFrequency">Frequency (Hz): <span id="effectFreqValue">1000</span></label>
        <input type="range" id="effectFilterFrequency" min="0" max="100" step="1" value="50">
      </div>
      <div class="control-group">
        <label for="effectFilterQ">Resonance (Q): <span id="effectQValue">1</span></label>
        <input type="range" id="effectFilterQ" min="0.0001" max="30" step="0.0001" value="1">
      </div>
      <div class="control-group" id="effectFilterGainGroup">
        <label for="effectFilterGain">Gain (dB): <span id="effectGainValue">0</span></label>
        <input type="range" id="effectFilterGain" min="-40" max="40" step="0.1" value="0">
      </div>
    </div>

    <!-- Reverb Controls -->
    <div style="margin-bottom: 20px; padding-bottom:15px; border-bottom: 1px solid #444;">
      <h3>Plate Reverb</h3>
      <div class="control-group">
        <label for="effectReverbMix">Reverb Mix (Dry/Wet): <span id="effectRevValue">0.50</span></label>
        <input type="range" id="effectReverbMix" min="0" max="1" step="0.01" value="0.5">
      </div>
      <div class="control-group">
        <label for="effectReverbPreDelay">Pre-Delay (ms): <span id="effectPDValue">20</span></label>
        <input type="range" id="effectReverbPreDelay" min="0" max="1000" step="10" value="20">
      </div>
      <div class="control-group">
        <label for="effectReverbDecay">Reverb Decay: <span id="effectDecayValue">0.50</span></label>
        <input type="range" id="effectReverbDecay" min="0" max="0.95" step="0.01" value="0.5">
      </div>
    </div>

    <!-- Effects Output Control -->
    <div>
      <h3>Effects Output</h3>
      <div class="control-group">
        <label for="midiInSelectEffectsOutput">MIDI Input:</label>
        <select id="midiInSelectEffectsOutput" style="width: auto; margin-bottom: 10px;">
          <option value="">-- no device --</option>
        </select>
      </div>
      <div class="control-group">
        <label for="effectsOutputVolume">Effects Output Volume: <span id="effectsVolValue">0.80</span></label>
        <input type="range" id="effectsOutputVolume" min="0" max="1" step="0.01" value="0.8">
        <button id="learnBtnEffectsOutput" style="margin-top: 5px; padding: 4px 8px; font-size: 12px;">MIDI Learn</button>
        <div id="statusEffectsOutput" style="margin-top: 5px; font-size: 11px; color: #aaa;">CC: -- | Value: 0.80</div>
      </div>
    </div>
  </div>

  <template id="waveModuleTemplate">
    <div class="wave-module" data-id="__id__">
      <div class="wave-trigger">☰ Settings</div>
      <div class="external-output">
        <canvas class="output-canvas"></canvas>
        <div class="value output-value">0.000</div>
      </div>
      <div class="settings">
        <div class="control-group">
          <label>Type</label>
          <select class="wave-type">
            <option value="sine">Sine</option>
            <option value="square">Square</option>
            <option value="sawtooth">Sawtooth</option>
            <option value="reverse-sawtooth">Reverse Saw</option>
            <option value="triangle">Triangle</option>
            <option value="reverse-triangle">Reverse Triangle</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="control-group custom-container" style="display:none;">
          <label>Draw Custom Wave</label>
          <canvas class="draw-canvas" width="200" height="80" style="border:1px solid #444; background:#fff;"></canvas>
          <button class="clear-draw" style="font-size:12px;margin-top:4px;">Clear</button>
        </div>
        <div class="control-group">
          <label>Speed (exp)</label>
          <input type="range" class="speed" min="-7" max="1" step="0.01" value="0">
          <div class="speed-display">1.0000000 Hz</div>
        </div>
        <div class="control-group speed-range-controls" style="/* Initially hide for modules 1-7 via JS if needed */">
          <label>Speed Min (log)</label>
          <input type="number" class="speed-min" value="-7" step="0.01">
          <label>Speed Max (log)</label>
          <input type="number" class="speed-max" value="1" step="0.01">
        </div>
        <div class="control-group">
          <label>Depth</label>
          <input type="range" class="depth" min="0" max="1" step="0.01" value="0.5">
          <div class="depth-display">0.50</div>
        </div>
        <div class="control-group">
          <label>Range</label>
          <input type="number" class="low" value="-1" step="any">
          <input type="number" class="high" value="1" step="any">
        </div>
        <div class="control-group">
          <label>Phase</label>
          <input type="range" class="phase" min="0" max="360" step="1" value="0">
          <div class="phase-display">0°</div>
        </div>
        <div class="control-group">
          <label>Log</label>
          <input type="range" class="log-scale" min="0.1" max="2" step="0.01" value="1">
          <div class="log-display">1.00</div>
        </div>
        <div class="control-group">
          <label>Enable</label>
          <input type="checkbox" class="enable">
        </div>
      </div>
    </div>
  </template>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const carrierOsc = audioCtx.createOscillator();
      const masterGain = audioCtx.createGain();
      const panner = audioCtx.createStereoPanner();
      // carrierOsc.connect(masterGain).connect(panner).connect(audioCtx.destination); // Old connection
      carrierOsc.connect(masterGain).connect(panner); // Connect synth output to panner
      carrierOsc.start();

      // --- BEGIN EFFECTS SECTION --- 
      const effectFilter = audioCtx.createBiquadFilter();
      const effectDryGain = audioCtx.createGain();
      const effectWetGain = audioCtx.createGain();
      const effectPreDelay = audioCtx.createDelay(1.0); // Max 1 second pre-delay
      const effectFeedback = audioCtx.createGain();
      const effectConvolver = audioCtx.createConvolver();
      const effectsFinalOutputVolume = audioCtx.createGain();

      // Connect panner output (main synth out) to the start of the effects chain
      panner.connect(effectFilter);

      // Generate impulse response for reverb
      function createIREffects(duration, decay) {
        const sr = audioCtx.sampleRate;
        const len = sr * duration;
        const buf = audioCtx.createBuffer(2, len, sr);
        for (let ch = 0; ch < 2; ch++) {
          const data = buf.getChannelData(ch);
          for (let i = 0; i < len; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decay);
          }
        }
        return buf;
      }
      effectConvolver.buffer = createIREffects(2, 2); // Default IR

      // Connect effects chain nodes
      effectFilter.connect(effectDryGain);          // Dry path
      effectFilter.connect(effectPreDelay);       // Wet path starts here
      effectPreDelay.connect(effectConvolver);
      effectConvolver.connect(effectFeedback);
      effectFeedback.connect(effectPreDelay);       // Feedback loop for plate reverb
      effectConvolver.connect(effectWetGain);       // Output from convolver to wet gain
      
      effectDryGain.connect(effectsFinalOutputVolume);
      effectWetGain.connect(effectsFinalOutputVolume);
      effectsFinalOutputVolume.connect(audioCtx.destination); // Final output of effects to destination

      // Helper for smooth parameter changes
      function smoothSetParam(param, value) { 
        if (param && typeof param.setTargetAtTime === 'function') {
            param.setTargetAtTime(value, audioCtx.currentTime, 0.01); 
        } else if (param && param.value !== undefined) {
            param.value = value; // For params that don't have setTargetAtTime (like delayTime on older APIs)
        }
      }
      // --- END EFFECTS SECTION --- 

      // Global controls
      document.getElementById('carrierType').addEventListener('change', e => { carrierOsc.type = e.target.value; });
      // document.getElementById('carrierFreq').addEventListener('input', e => { carrierOsc.frequency.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); }); // Managed in modulationLoop
      // document.getElementById('masterVol').addEventListener('input', e => { masterGain.gain.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); });   // Managed in modulationLoop
      document.getElementById('detune').addEventListener('input', e => { carrierOsc.detune.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); });
      document.getElementById('pan').addEventListener('input', e => { panner.pan.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); });

      const carrierFreqSlider = document.getElementById('carrierFreq');
      const carrierFreqDisplay = document.getElementById('carrierFreqDisplay');
      carrierFreqSlider.addEventListener('input', e => { carrierFreqDisplay.textContent = e.target.value; });

      const testSlider = document.getElementById('testSlider');
      const testSliderDisplay = document.getElementById('testSliderDisplay');
      testSlider.addEventListener('input', e => { testSliderDisplay.textContent = parseFloat(e.target.value).toFixed(2); });

      const test2Slider = document.getElementById('test2Slider');
      const test2SliderDisplay = document.getElementById('test2SliderDisplay');
      test2Slider.addEventListener('input', e => { test2SliderDisplay.textContent = parseFloat(e.target.value).toFixed(2); });

      // --- BEGIN EFFECTS PARAMETER CONTROL ---
      const effectElems = {};
      ['effectFilterType', 'effectFilterFrequency', 'effectFilterQ', 'effectFilterGain', 'effectReverbMix', 'effectReverbPreDelay', 'effectReverbDecay', 'effectsOutputVolume']
        .forEach(id => effectElems[id] = document.getElementById(id));
      ['effectFreqValue', 'effectQValue', 'effectGainValue', 'effectRevValue', 'effectPDValue', 'effectDecayValue', 'effectsVolValue']
        .forEach(id => effectElems[id] = document.getElementById(id));
      const effectFilterGainGroup = document.getElementById('effectFilterGainGroup');

      function updateEffectsParams() {
        if (!effectFilter || !audioCtx) return; // Ensure nodes are ready

        effectFilter.type = effectElems.effectFilterType.value;
        const frac = +effectElems.effectFilterFrequency.value / 100;
        const logMin = Math.log10(20), logMax = Math.log10(20000);
        const freq = Math.pow(10, logMin + (logMax - logMin) * frac);
        smoothSetParam(effectFilter.frequency, freq);
        smoothSetParam(effectFilter.Q, +effectElems.effectFilterQ.value);
        smoothSetParam(effectFilter.gain, +effectElems.effectFilterGain.value);
        effectElems.effectFreqValue.textContent = freq.toFixed(1);
        effectElems.effectQValue.textContent = (+effectElems.effectFilterQ.value).toFixed(2);
        effectElems.effectGainValue.textContent = effectElems.effectFilterGain.value;
        effectFilterGainGroup.style.display = ['lowshelf', 'highshelf', 'peaking'].includes(effectFilter.type) ? 'block' : 'none';

        // Reverb
        smoothSetParam(effectPreDelay.delayTime, +effectElems.effectReverbPreDelay.value / 1000);
        smoothSetParam(effectWetGain.gain, +effectElems.effectReverbMix.value);
        smoothSetParam(effectDryGain.gain, 1 - +effectElems.effectReverbMix.value);
        smoothSetParam(effectFeedback.gain, +effectElems.effectReverbDecay.value);
        effectElems.effectRevValue.textContent = (+effectElems.effectReverbMix.value).toFixed(2);
        effectElems.effectPDValue.textContent = effectElems.effectReverbPreDelay.value;
        effectElems.effectDecayValue.textContent = (+effectElems.effectReverbDecay.value).toFixed(2);

        // Effects Output Volume
        smoothSetParam(effectsFinalOutputVolume.gain, +effectElems.effectsOutputVolume.value);
        effectElems.effectsVolValue.textContent = (+effectElems.effectsOutputVolume.value).toFixed(2);
      }

      ['effectFilterType', 'effectFilterFrequency', 'effectFilterQ', 'effectFilterGain', 'effectReverbMix', 'effectReverbPreDelay', 'effectReverbDecay', 'effectsOutputVolume']
        .forEach(id => {
          if (effectElems[id]) {
            effectElems[id].addEventListener('input', updateEffectsParams);
          }
        });
      
      updateEffectsParams(); // Initial call to set parameters
      // --- END EFFECTS PARAMETER CONTROL ---

      // Create modules
      const container = document.getElementById('modulesContainer');
      const template = document.getElementById('waveModuleTemplate').innerHTML;
      const modules = [];
      for (let i = 0; i < 8; i++) {
        const html = template.replace(/__id__/g, i);
        container.insertAdjacentHTML('beforeend', html);
        modules.push(new WaveModule(container.children[i], audioCtx));
      }

      // Modulation loop
      function modulationLoop() {
        // Carrier Frequency: Controlled by global knob, additively modulated by modules[0]
        const carrierFreqKnobVal = parseFloat(document.getElementById('carrierFreq').value);
        let finalCarrierFreq = carrierFreqKnobVal; // Start with the knob value
        if (modules[0].isPlaying) {
            const freqModSignal = parseFloat(modules[0].outputValue.textContent);
            if (!isNaN(freqModSignal)) { // Check if output is a valid number
                finalCarrierFreq += freqModSignal; // Add module 0 output to the knob value
            }
        }
        carrierOsc.frequency.setValueAtTime(Math.max(1, finalCarrierFreq), audioCtx.currentTime); // Min 1Hz

        // Master Volume: Controlled by global knob, multiplicatively modulated by modules[1]
        const masterVolKnobVal = parseFloat(document.getElementById('masterVol').value);
        let finalMasterGainMultiplier = 1.0; // Default to no modulation on gain knob value
        if (modules[1].isPlaying) {
            const ampModSignal = parseFloat(modules[1].outputValue.textContent);
            if (!isNaN(ampModSignal)) {
                finalMasterGainMultiplier = ampModSignal;
            }
        }
        const targetMasterGain = Math.max(0, masterVolKnobVal * finalMasterGainMultiplier);
        // Smooth gain changes to prevent clicks
        masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime); // Cancel previous automations and set current value
        masterGain.gain.linearRampToValueAtTime(targetMasterGain, audioCtx.currentTime + 0.01); // Ramp to new target in 10ms

        // Module 2 output controls the global "Test" slider
        let targetTestSliderValue = parseFloat(document.getElementById('testSlider').value); // Keep current if module 2 is off
        if (modules[2].isPlaying) {
            const mod2Output = parseFloat(modules[2].outputValue.textContent);
            if (!isNaN(mod2Output)) {
                // Directly use module 2's output, clamped to Test slider's range
                targetTestSliderValue = Math.max(-7, Math.min(1, mod2Output)); 
            }
        }
        document.getElementById('testSlider').value = targetTestSliderValue;
        document.getElementById('testSliderDisplay').textContent = targetTestSliderValue.toFixed(2);
        
        // Module 0 Speed: "Test" slider (now driven by module 2) controls it, scaled by module 0's own speed min/max settings.
        const testSliderRawValue = targetTestSliderValue; // Use the value we just set for the Test slider
        const testSliderMinFixed = -7; // Fixed range of the global Test slider
        const testSliderMaxFixed = 1;  // Fixed range of the global Test slider

        // Normalize testSliderRawValue to a 0-1 range
        const normalizedTestValue = (testSliderRawValue - testSliderMinFixed) / (testSliderMaxFixed - testSliderMinFixed);

        let mod0MinLogSpeed = parseFloat(modules[0].prefs.speedMin.value);
        let mod0MaxLogSpeed = parseFloat(modules[0].prefs.speedMax.value);

        // Validate and set default for module 0's dynamic range if necessary
        if (isNaN(mod0MinLogSpeed) || isNaN(mod0MaxLogSpeed) || mod0MinLogSpeed >= mod0MaxLogSpeed) {
            mod0MinLogSpeed = -7; // Default min for module 0's effective range
            mod0MaxLogSpeed = 1;  // Default max for module 0's effective range
            // Optionally update the input fields if they were invalid
            modules[0].prefs.speedMin.value = mod0MinLogSpeed;
            modules[0].prefs.speedMax.value = mod0MaxLogSpeed;
        }

        // Update module 0's speed slider's actual min and max attributes
        modules[0].prefs.speed.min = mod0MinLogSpeed;
        modules[0].prefs.speed.max = mod0MaxLogSpeed;

        // Scale the normalizedTestValue to the new dynamic range of module 0's slider
        let targetMod0LogSpeed = mod0MinLogSpeed + (normalizedTestValue * (mod0MaxLogSpeed - mod0MinLogSpeed));
        
        // The step attribute of module 0's speed slider (modules[0].prefs.speed.step) remains 0.01 by default.
        // If the dynamic range (mod0MaxLogSpeed - mod0MinLogSpeed) becomes very small, the slider might feel coarse.
        // If it becomes very large, it might feel too fine. For now, 0.01 is kept.

        modules[0].setSpeed(targetMod0LogSpeed);

        // Module 3 output controls the global "Test2" slider (as before)
        let targetTest2SliderValue = parseFloat(document.getElementById('test2Slider').value); 
        if (modules[3].isPlaying) {
            const mod3Output = parseFloat(modules[3].outputValue.textContent);
            if (!isNaN(mod3Output)) {
                targetTest2SliderValue = Math.max(-7, Math.min(1, mod3Output)); 
            }
        }
        document.getElementById('test2Slider').value = targetTest2SliderValue;
        document.getElementById('test2SliderDisplay').textContent = targetTest2SliderValue.toFixed(2);

        // Module 1 Speed: "Test2" slider (driven by module 3) controls it, scaled by module 1's own speed min/max settings.
        const test2SliderRawValue = targetTest2SliderValue; // Value from Test2 slider (which is -7 to 1 log)
        const test2SliderMinFixed = -7; // Fixed range of the global Test2 slider
        const test2SliderMaxFixed = 1;  // Fixed range of the global Test2 slider

        // Normalize test2SliderRawValue to a 0-1 range
        const normalizedTest2Value = (test2SliderRawValue - test2SliderMinFixed) / (test2SliderMaxFixed - test2SliderMinFixed);

        let mod1MinLogSpeed = parseFloat(modules[1].prefs.speedMin.value);
        let mod1MaxLogSpeed = parseFloat(modules[1].prefs.speedMax.value);

        // Validate and set default for module 1's dynamic range if necessary
        if (isNaN(mod1MinLogSpeed) || isNaN(mod1MaxLogSpeed) || mod1MinLogSpeed >= mod1MaxLogSpeed) {
            mod1MinLogSpeed = -7; 
            mod1MaxLogSpeed = 1;  
            modules[1].prefs.speedMin.value = mod1MinLogSpeed;
            modules[1].prefs.speedMax.value = mod1MaxLogSpeed;
        }

        // Update module 1's speed slider's actual min and max attributes
        modules[1].prefs.speed.min = mod1MinLogSpeed;
        modules[1].prefs.speed.max = mod1MaxLogSpeed;

        // Scale the normalizedTest2Value to the new dynamic range of module 1's slider
        let targetMod1LogSpeed = mod1MinLogSpeed + (normalizedTest2Value * (mod1MaxLogSpeed - mod1MinLogSpeed));
        
        modules[1].setSpeed(targetMod1LogSpeed);

        requestAnimationFrame(modulationLoop);
      }
      modulationLoop();
      // Export settings as JSON
      document.getElementById('exportBtn').addEventListener('click', () => {
        const settings = {
          carrier: {
            type: document.getElementById('carrierType').value,
            freq: parseFloat(document.getElementById('carrierFreq').value),
            vol: parseFloat(document.getElementById('masterVol').value),
            detune: parseFloat(document.getElementById('detune').value),
            pan: parseFloat(document.getElementById('pan').value)
          },
          modules: modules.map(m => m.getSettings()),
          effects: {
            filterType: effectElems.effectFilterType.value,
            filterFrequency: effectElems.effectFilterFrequency.value, // Store raw slider value (0-100)
            filterQ: effectElems.effectFilterQ.value,
            filterGain: effectElems.effectFilterGain.value,
            reverbMix: effectElems.effectReverbMix.value,
            reverbPreDelay: effectElems.effectReverbPreDelay.value,
            reverbDecay: effectElems.effectReverbDecay.value,
            outputVolume: effectElems.effectsOutputVolume.value
          }
        };
        const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'wave-settings.json';
        a.click();
        URL.revokeObjectURL(url);
      });
      // Import settings
      document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
      document.getElementById('importFile').addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
          try {
            const settings = JSON.parse(ev.target.result);
            applyImportedSettings(settings); // Use a new function to apply settings
          } catch (err) {
            console.error('Failed to import settings:', err);
          }
        };
        reader.readAsText(file);
      });

      // Function to apply settings (used by both import and preset loading)
      function applyImportedSettings(settings) {
        // Apply carrier settings
        const c = settings.carrier;
        if (c) {
          document.getElementById('carrierType').value = c.type || "sine";
          document.getElementById('carrierFreq').value = c.freq !== undefined ? c.freq : 440;
          document.getElementById('masterVol').value = c.vol !== undefined ? c.vol : 0.5;
          document.getElementById('detune').value = c.detune !== undefined ? c.detune : 0;
          document.getElementById('pan').value = c.pan !== undefined ? c.pan : 0;
          
          // Trigger events to update displays and audio params
          ['carrierType'].forEach(id => document.getElementById(id).dispatchEvent(new Event('change')));
          ['carrierFreq', 'masterVol', 'detune', 'pan'].forEach(id => {
              document.getElementById(id).dispatchEvent(new Event('input'));
          });
          // Update displays linked to sliders not directly in updateEffectsParams or modulationLoop
          if (document.getElementById('carrierFreqDisplay')) {
            document.getElementById('carrierFreqDisplay').textContent = document.getElementById('carrierFreq').value;
          }
          if (document.getElementById('masterVolDisplay')) { // If masterVolDisplay exists
             document.getElementById('masterVolDisplay').dispatchEvent(new Event('input')); // Trigger its own input if it has specific logic
          }
        }
        // Apply module settings
        if (Array.isArray(settings.modules)) {
          settings.modules.forEach((mod, idx) => {
            if (modules[idx] && typeof modules[idx].applySettings === 'function') {
              modules[idx].applySettings(mod);
            }
          });
        }
        // Apply effects settings
        const fx = settings.effects;
        if (fx) {
          effectElems.effectFilterType.value = fx.filterType || 'lowpass';
          effectElems.effectFilterFrequency.value = fx.filterFrequency !== undefined ? fx.filterFrequency : 50;
          effectElems.effectFilterQ.value = fx.filterQ !== undefined ? fx.filterQ : 1;
          effectElems.effectFilterGain.value = fx.filterGain !== undefined ? fx.filterGain : 0;
          effectElems.effectReverbMix.value = fx.reverbMix !== undefined ? fx.reverbMix : 0.5;
          effectElems.effectReverbPreDelay.value = fx.reverbPreDelay !== undefined ? fx.reverbPreDelay : 20;
          effectElems.effectReverbDecay.value = fx.reverbDecay !== undefined ? fx.reverbDecay : 0.5;
          effectElems.effectsOutputVolume.value = fx.outputVolume !== undefined ? fx.outputVolume : 0.8;
          
          // Trigger input events to update displays and audio params via updateEffectsParams
          ['effectFilterType', 'effectFilterFrequency', 'effectFilterQ', 'effectFilterGain', 'effectReverbMix', 'effectReverbPreDelay', 'effectReverbDecay', 'effectsOutputVolume']
            .forEach(id => {
              if (effectElems[id]) {
                  effectElems[id].dispatchEvent(new Event('input'));
              }
          });
          // updateEffectsParams(); // Call directly after setting all values, or rely on dispatched events.
        }
        // Update MIDI control statuses if they exist and have bound CCs
        if (typeof updateEffectsOutputStatus === 'function') updateEffectsOutputStatus();
        if (typeof updateMasterVolStatus === 'function') updateMasterVolStatus();
      }

      // --- BEGIN PRESET LOADING ---
      const presetSelector = document.getElementById('presetSelector');
      const presetFiles = [
        "presets/wave-settings (1).json",
        "presets/wave-settings (2).json",
        "presets/wave-settings (3).json",
        "presets/wave-settings (4).json",
        "presets/wave-settings (5).json",
        "presets/wave-settings (6).json",
        "presets/wave-settings (7).json",
        "presets/wave-settings (8).json",
        "presets/wave-settings (9).json",
        "presets/wave-settings (10).json",
        "presets/wave-settings (11).json",
        "presets/wave-settings (12).json",
        "presets/wave-settings (13).json",
        "presets/wave-settings (14).json",
        "presets/wave-settings (15).json",
        "presets/wave-settings (16).json",
        "presets/wave-settings (17).json",
        "presets/wave-settings (18).json",
        "presets/wave-settings (19).json",
        "presets/wave-settings (20).json",
        "presets/wave-settings (21).json",
        "presets/wave-settings (22).json",
        "presets/wave-settings (23).json",
        "presets/wave-settings (24).json",
        "presets/wave-settings (25).json",
        "presets/wave-settings (26).json",
        "presets/wave-settings (27).json",
        "presets/wave-settings (28).json",
        "presets/wave-settings (29).json",
        "presets/wave-settings (30).json",
        "presets/wave-settings.json"
      ];

      function populatePresetDropdown() {
        if (!presetSelector) return;
        presetFiles.forEach(filePath => {
          const option = document.createElement('option');
          option.value = filePath;
          option.text = filePath.split('/').pop(); // Show only filename
          presetSelector.appendChild(option);
        });
      }

      presetSelector.addEventListener('change', async (event) => {
        const filePath = event.target.value;
        if (!filePath) return;

        try {
          const response = await fetch(filePath);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} while fetching ${filePath}`);
          }
          const settings = await response.json();
          applyImportedSettings(settings);
          console.log(`Loaded preset: ${filePath}`);
        } catch (error) {
          console.error('Error loading preset:', error);
          alert(`Failed to load preset: ${filePath}\nError: ${error.message}`);
        }
      });
      
      populatePresetDropdown(); // Populate on script load
      // --- END PRESET LOADING ---

      // --- BEGIN MIDI LEARN FOR MASTER VOLUME ---
      let midiAccess = null;
      let learnModeMasterVol = false;
      let boundCCMasterVol = null;
      let currentMidiInput = null;

      const masterVolSlider = document.getElementById('masterVol');
      const learnBtnMasterVol = document.getElementById('learnBtnMasterVol');
      const statusMasterVol = document.getElementById('statusMasterVol');
      const midiInSelectMasterVol = document.getElementById('midiInSelectMasterVol');
      const masterVolValueDisplay = document.getElementById('masterVolDisplay'); // Get the span for value display

      function updateMasterVolStatus() {
        const sliderVal = parseFloat(masterVolSlider.value).toFixed(2);
        statusMasterVol.textContent = `CC: ${boundCCMasterVol !== null ? boundCCMasterVol : '--'} | Value: ${sliderVal}`;
        masterVolValueDisplay.textContent = sliderVal; // Also update the main display span
      }

      if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
      } else {
        console.warn('Web MIDI API not supported in this browser.');
        if(learnBtnMasterVol) learnBtnMasterVol.disabled = true;
        if(midiInSelectMasterVol) midiInSelectMasterVol.disabled = true;
      }

      function onMIDISuccess(access) {
        midiAccess = access;
        if (!midiInSelectMasterVol) return;
        // Populate input selector
        midiInSelectMasterVol.innerHTML = '<option value="">-- no device --</option>'; // Clear previous options
        for (let input of midiAccess.inputs.values()) {
          const option = document.createElement('option');
          option.value = input.id;
          option.text = input.name || input.manufacturer || input.id;
          midiInSelectMasterVol.appendChild(option);
        }
        // Change handler for MIDI input selection
        midiInSelectMasterVol.addEventListener('change', () => {
          if (currentMidiInput) currentMidiInput.onmidimessage = null;
          currentMidiInput = midiAccess.inputs.get(midiInSelectMasterVol.value) || null;
          if (currentMidiInput) currentMidiInput.onmidimessage = handleMIDIMessageMasterVol;
          console.log(currentMidiInput ? `Selected MIDI Input: ${currentMidiInput.name}` : 'No MIDI Input selected');
        });
      }

      function onMIDIFailure() {
        console.error('Could not access your MIDI devices.');
        if(learnBtnMasterVol) learnBtnMasterVol.disabled = true;
        if(midiInSelectMasterVol) midiInSelectMasterVol.disabled = true;
      }

      function handleMIDIMessageMasterVol(event) {
        const [statusByte, data1, data2] = event.data;
        const type = statusByte & 0xf0; // MIDI message type (e.g., 0xB0 for CC)
        // const channel = statusByte & 0x0f; // MIDI channel

        if (type === 0xB0) { // Control Change message
          const cc = data1;    // CC number
          const value = data2; // CC value (0-127)

          if (learnModeMasterVol) {
            boundCCMasterVol = cc;
            learnModeMasterVol = false;
            learnBtnMasterVol.textContent = 'MIDI Learned!';
            learnBtnMasterVol.style.backgroundColor = '#77dd77'; // Greenish feedback
            updateMasterVolStatus();
            setTimeout(() => {
                learnBtnMasterVol.textContent = 'MIDI Learn';
                learnBtnMasterVol.style.backgroundColor = ''; // Reset background
            }, 1500);
          }

          if (cc === boundCCMasterVol) {
            const normalizedValue = value / 127; // Normalize to 0-1 range for the slider
            masterVolSlider.value = normalizedValue.toFixed(2);
            // Dispatch an input event to trigger existing audio updates and UI changes
            masterVolSlider.dispatchEvent(new Event('input')); 
            updateMasterVolStatus(); // update status after dispatching event
          }
        }
      }

      if (learnBtnMasterVol) {
          learnBtnMasterVol.addEventListener('click', () => {
            if (!midiAccess) {
                alert('MIDI not initialized. Please select a MIDI input if available, or check browser permissions.');
                return;
            }
            if (!currentMidiInput && midiInSelectMasterVol.value === ""){
                alert('Please select a MIDI input device first.');
                return;
            }
            learnModeMasterVol = true;
            learnBtnMasterVol.textContent = 'Listening...';
            learnBtnMasterVol.style.backgroundColor = '#ffcc00'; // Yellowish feedback
        });
      }

      // Update status display when slider is changed manually
      if (masterVolSlider) {
          masterVolSlider.addEventListener('input', updateMasterVolStatus);
      }
      // Initialize status on load
      updateMasterVolStatus(); 
      // --- END MIDI LEARN FOR MASTER VOLUME ---

    });

    class WaveModule {
      constructor(root, audioCtx) {
        this.root = root;
        this.audioCtx = audioCtx;
        this.customPoints = [];
        this.history = [];
        this.isPlaying = false;
        this.startTime = 0;
        this.lastSpeed = 1;
        this.outputValue = root.querySelector('.output-value');
        this.outputCanvas = root.querySelector('.output-canvas'); this.outputCanvas.width = 200; this.outputCanvas.height = 50;
        this.outputCtx = this.outputCanvas.getContext('2d');
        this.trigger = root.querySelector('.wave-trigger');
        this.settings = root.querySelector('.settings');
        this.prefs = {
          waveType: root.querySelector('.wave-type'),
          customContainer: root.querySelector('.custom-container'),
          drawCanvas: root.querySelector('.draw-canvas'),
          drawCtx: root.querySelector('.draw-canvas') ? root.querySelector('.draw-canvas').getContext('2d') : null,
          clearDraw: root.querySelector('.clear-draw'),
          speed: root.querySelector('.speed'), speedDisplay: root.querySelector('.speed-display'),
          speedMin: root.querySelector('.speed-min'),
          speedMax: root.querySelector('.speed-max'),
          speedRangeControls: root.querySelector('.speed-range-controls'),
          depth: root.querySelector('.depth'), depthDisplay: root.querySelector('.depth-display'),
          low: root.querySelector('.low'), high: root.querySelector('.high'),
          phase: root.querySelector('.phase'), phaseDisplay: root.querySelector('.phase-display'),
          log: root.querySelector('.log-scale'), logDisplay: root.querySelector('.log-display'),
          enable: root.querySelector('.enable')
        };
        this.bind();
        // Hide speed range controls if not module 0 or module 1
        if (this.root.dataset.id !== '0' && this.root.dataset.id !== '1' && this.prefs.speedRangeControls) {
            this.prefs.speedRangeControls.style.display = 'none';
        }
      }
      bind() {
        const p = this.prefs;
        this.trigger.addEventListener('click', () => this.settings.style.display = this.settings.style.display === 'block' ? 'none' : 'block');
        p.enable.addEventListener('change', () => { this.isPlaying = p.enable.checked; this.audioCtx.resume(); if (this.isPlaying) { this.startTime = Date.now(); this.history = []; this.update(); }});
        p.waveType.addEventListener('change', () => {
            p.customContainer.style.display = p.waveType.value === 'custom' ? 'block' : 'none';
            this.redrawDrawCanvas(); // Redraw when type changes, might be to/from custom
        });
        if (p.drawCanvas) {
          let drawing = false;
          p.drawCanvas.addEventListener('mousedown', e => { if (p.waveType.value!=='custom') return; drawing=true; this.customPoints=[]; p.drawCtx.clearRect(0,0,p.drawCanvas.width,p.drawCanvas.height); p.drawCtx.beginPath(); const r=p.drawCanvas.getBoundingClientRect(); const pt={x:e.clientX-r.left, y:e.clientY-r.top}; p.drawCtx.moveTo(pt.x,pt.y); this.customPoints.push(pt); });
          p.drawCanvas.addEventListener('mousemove', e => { if (!drawing) return; const r=p.drawCanvas.getBoundingClientRect(); const pt={x:e.clientX-r.left, y:e.clientY-r.top}; this.customPoints.push(pt); p.drawCtx.lineTo(pt.x,pt.y); p.drawCtx.strokeStyle='#61dafb';p.drawCtx.lineWidth=2;p.drawCtx.stroke(); });
          ['mouseup','mouseleave'].forEach(evt=>p.drawCanvas.addEventListener(evt,()=>drawing=false));
          p.clearDraw.addEventListener('click',()=>{p.drawCtx.clearRect(0,0,p.drawCanvas.width,p.drawCanvas.height); this.customPoints=[];});
        }
        p.speed.addEventListener('input', () => this.setSpeed(this.prefs.speed.value));
        p.depth.addEventListener('input',()=>p.depthDisplay.textContent=parseFloat(p.depth.value).toFixed(2));
        p.phase.addEventListener('input',()=>p.phaseDisplay.textContent=p.phase.value+'°');
        p.log.addEventListener('input',()=>p.logDisplay.textContent=parseFloat(p.log.value).toFixed(2));
      }
      setSpeed(newLogSpeed) {
        // Ensure newLogSpeed is a number
        newLogSpeed = parseFloat(newLogSpeed);
        if (isNaN(newLogSpeed)) return; // Safety check

        // Update the slider's visual position if it's not already there
        if (parseFloat(this.prefs.speed.value) !== newLogSpeed) {
            this.prefs.speed.value = newLogSpeed;
        }

        const newSpeedHz = Math.pow(10, newLogSpeed);
        const now = Date.now();

        // Phase correction logic
        // this.lastSpeed is the speed *before* this change
        // this.startTime is the startTime for the speed *before* this change
        const elapsedSinceLastStartTime = (now - this.startTime) / 1000;
        const currentPhaseProgress = (elapsedSinceLastStartTime * this.lastSpeed) % 1;

        this.lastSpeed = newSpeedHz; // Update to the new speed in Hz
        // Adjust startTime for phase continuity: startTime = now - time_into_new_cycle
        // time_into_new_cycle = currentPhaseProgress / newSpeedHz (if currentPhaseProgress is in cycles)
        this.startTime = now - (currentPhaseProgress / newSpeedHz) * 1000;
        if (newSpeedHz === 0) { // Avoid division by zero if speed is set to effectively zero
            this.startTime = now; 
        }

        this.prefs.speedDisplay.textContent = newSpeedHz.toFixed(7) + ' Hz';
      }
      calculate(t) {
        const p=this.prefs,dep=parseFloat(p.depth.value);
        let raw=t,logS=parseFloat(p.log.value);
        raw=logS===1?raw:(Math.log(raw*(logS-1)+1)/Math.log(logS));
        const phase=(raw*2*Math.PI+parseFloat(p.phase.value)*Math.PI/180);
        let v=0;
        switch(p.waveType.value){
          case 'sine': v=Math.sin(phase);break;
          case 'square': v=Math.sign(Math.sin(phase));break;
          case 'sawtooth': v=2*(raw-0.5);break;
          case 'reverse-sawtooth': v=2*(0.5-raw);break;
          case 'triangle': v=2*Math.abs(2*(raw-0.5))-1;break;
          case 'reverse-triangle': v=1-2*Math.abs(2*(raw-0.5));break;
          case 'custom': if(this.customPoints.length>1){const pts=this.customPoints, idx=raw*(pts.length-1),i=Math.floor(idx),ni=(i+1)%pts.length,f=idx-i; const y=pts[i].y*(1-f)+pts[ni].y*f; v=1-2*(y/this.prefs.drawCanvas.height);}break;
        }
        return v*dep;
      }
      update(){ if(!this.isPlaying) return; const t=((Date.now()-this.startTime)/1000*this.lastSpeed)%1; const val=this.calculate(t); const low=parseFloat(this.prefs.low.value),high=parseFloat(this.prefs.high.value); const sc=low+(val+1)*(high-low)/2; this.outputValue.textContent=sc.toFixed(3); this.history.push(sc); if(this.history.length>this.outputCanvas.width) this.history.shift(); const c=this.outputCtx; c.fillStyle='#282c34';c.fillRect(0,0,this.outputCanvas.width,this.outputCanvas.height); c.beginPath();c.strokeStyle='#61dafb';c.lineWidth=2; this.history.forEach((v,i)=>{const y=this.outputCanvas.height-((v-low)/(high-low))*this.outputCanvas.height; i===0?c.moveTo(i,y):c.lineTo(i,y);});c.stroke(); requestAnimationFrame(()=>this.update()); }
      getSettings() {
        const p = this.prefs;
        return {
          id: this.root.dataset.id,
          waveType: p.waveType.value,
          customPoints: this.customPoints,
          speed: parseFloat(p.speed.value),
          speedMin: p.speedMin ? parseFloat(p.speedMin.value) : -7,
          speedMax: p.speedMax ? parseFloat(p.speedMax.value) : 1,
          depth: parseFloat(p.depth.value),
          low: parseFloat(p.low.value),
          high: parseFloat(p.high.value),
          phase: parseInt(p.phase.value),
          logScale: parseFloat(p.log.value),
          enabled: p.enable.checked
        };
      }
      applySettings(s) {
        if (!s) return;
        const p = this.prefs;

        p.waveType.value = s.waveType || 'sine';
        this.customPoints = s.customPoints || [];
        p.customContainer.style.display = p.waveType.value === 'custom' ? 'block' : 'none';
        this.redrawDrawCanvas();

        // Restore speedMin and speedMax for module 0 if they exist on prefs
        if (p.speedMin) {
            p.speedMin.value = s.speedMin !== undefined ? s.speedMin : -7;
        }
        if (p.speedMax) {
            p.speedMax.value = s.speedMax !== undefined ? s.speedMax : 1;
        }

        // The actual speed slider value (p.speed.value) will be set by setSpeed via modulationLoop
        // For initial load, if not playing, we can set it here or rely on setSpeed being called.
        // However, setSpeed itself will be called in modulationLoop based on these min/max and testSlider.

        p.depth.value = s.depth !== undefined ? s.depth : 0.5;
        p.depthDisplay.textContent = parseFloat(p.depth.value).toFixed(2);

        p.low.value = s.low !== undefined ? s.low : -1;
        p.high.value = s.high !== undefined ? s.high : 1;

        p.phase.value = s.phase !== undefined ? s.phase : 0;
        p.phaseDisplay.textContent = p.phase.value + '°';

        p.log.value = s.logScale !== undefined ? s.logScale : 1;
        p.logDisplay.textContent = parseFloat(p.log.value).toFixed(2);
        
        p.enable.checked = s.enabled || false;
        this.isPlaying = p.enable.checked;
        if (this.isPlaying) {
            this.startTime = Date.now(); // Reset start time on enable
            this.history = [];
            this.update(); 
        } else {
            // Clear output display if not playing
            this.outputValue.textContent = (0).toFixed(3);
            const c = this.outputCtx;
            c.fillStyle = '#282c34';
            c.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
        }
      }
      
      redrawDrawCanvas() {
        if (this.prefs.waveType.value === 'custom' && this.prefs.drawCtx) {
            const ctx = this.prefs.drawCtx;
            const canvas = this.prefs.drawCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (this.customPoints && this.customPoints.length > 1) {
                ctx.beginPath();
                ctx.moveTo(this.customPoints[0].x, this.customPoints[0].y);
                for (let i = 1; i < this.customPoints.length; i++) {
                    ctx.lineTo(this.customPoints[i].x, this.customPoints[i].y);
                }
                ctx.strokeStyle = '#61dafb';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
      }
    }
  </script>
</body>
</html>

