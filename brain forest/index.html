<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wave Modules with Carrier Controls</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #282c34; color: #eee; margin: 0; padding: 20px; }
    .global-controls { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .modules-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }
    .wave-module { background: #1a1d23; padding: 10px; border-radius: 8px; position: relative; }
    .wave-trigger { cursor: pointer; color: #61dafb; font-size: 18px; }
    .settings { display: none; margin-top: 10px; background: #2b2f36; padding: 8px; border-radius: 6px; }
    .control-group { margin-bottom: 8px; }
    .control-group label { color: #61dafb; font-size: 12px; display: block; margin-bottom: 4px; }
    .control-group select, .control-group input { width: 100%; padding: 4px; background: #1a1d23; border: 1px solid #444; border-radius: 4px; color: #eee; font-size: 12px; }
    .external-output { margin-top: 10px; text-align: center; }
    .external-output canvas { width: 100%; height: 50px; background: #282c34; display: block; }
    .value { color: #61dafb; font-family: monospace; margin-top: 4px; }
  </style>
</head>
<body>
  <div class="global-controls">
    <button id="exportBtn">Export All</button>
    <button id="importBtn">Import</button>
    <input type="file" id="importFile" accept="application/json" style="display:none;">
    <label>Wave:</label>
    <select id="carrierType">
      <option value="sine">Sine</option>
      <option value="square">Square</option>
      <option value="sawtooth">Sawtooth</option>
      <option value="reverse-sawtooth">Reverse Saw</option>
      <option value="triangle">Triangle</option>
      <option value="reverse-triangle">Reverse Triangle</option>
    </select>
    <label>Freq:</label><input type="range" id="carrierFreq" min="20" max="2000" value="440" step="1" style="width:120px;"><span id="carrierFreqDisplay" style="width:40px; display:inline-block; text-align:right;">440</span><span>Hz</span>
    <label>Vol:</label><input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.5">
    <label>Detune:</label><input type="range" id="detune" min="-100" max="100" step="1" value="0">
    <label>Pan:</label><input type="range" id="pan" min="-1" max="1" step="0.01" value="0">
    <label>Test:</label><input type="range" id="testSlider" min="-7" max="1" step="0.01" value="0" style="width:120px;"><span id="testSliderDisplay" style="width:50px; display:inline-block; text-align:right;">0.00</span>
    <label>Test2:</label><input type="range" id="test2Slider" min="-7" max="1" step="0.01" value="0" style="width:120px;"><span id="test2SliderDisplay" style="width:50px; display:inline-block; text-align:right;">0.00</span>
  </div>

  <div class="modules-container" id="modulesContainer"></div>

  <!-- Added Filter and Reverb Controls -->
  <div class="control-group" style="margin-top: 30px; padding: 15px; border: 1px solid #555; border-radius: 8px;">
    <h2>Effects Section</h2>
    
    <!-- Filter Controls -->
    <div style="margin-bottom: 20px; padding-bottom:15px; border-bottom: 1px solid #444;">
      <h3>Filter</h3>
      <div class="control-group">
        <label for="effectFilterType">Filter Type:</label>
        <select id="effectFilterType" style="width: auto;">
          <option value="lowpass">Low-pass</option>
          <option value="highpass">High-pass</option>
          <option value="bandpass">Band-pass</option>
          <option value="lowshelf">Low-shelf</option>
          <option value="highshelf">High-shelf</option>
          <option value="peaking">Peaking</option>
          <option value="notch">Notch</option>
          <option value="allpass">All-pass</option>
        </select>
      </div>
      <div class="control-group">
        <label for="effectFilterFrequency">Frequency (Hz): <span id="effectFreqValue">1000</span></label>
        <input type="range" id="effectFilterFrequency" min="0" max="100" step="1" value="50">
      </div>
      <div class="control-group">
        <label for="effectFilterQ">Resonance (Q): <span id="effectQValue">1</span></label>
        <input type="range" id="effectFilterQ" min="0.0001" max="30" step="0.0001" value="1">
      </div>
      <div class="control-group" id="effectFilterGainGroup">
        <label for="effectFilterGain">Gain (dB): <span id="effectGainValue">0</span></label>
        <input type="range" id="effectFilterGain" min="-40" max="40" step="0.1" value="0">
      </div>
    </div>

    <!-- Reverb Controls -->
    <div style="margin-bottom: 20px; padding-bottom:15px; border-bottom: 1px solid #444;">
      <h3>Plate Reverb</h3>
      <div class="control-group">
        <label for="effectReverbMix">Reverb Mix (Dry/Wet): <span id="effectRevValue">0.50</span></label>
        <input type="range" id="effectReverbMix" min="0" max="1" step="0.01" value="0.5">
      </div>
      <div class="control-group">
        <label for="effectReverbPreDelay">Pre-Delay (ms): <span id="effectPDValue">20</span></label>
        <input type="range" id="effectReverbPreDelay" min="0" max="1000" step="10" value="20">
      </div>
      <div class="control-group">
        <label for="effectReverbDecay">Reverb Decay: <span id="effectDecayValue">0.50</span></label>
        <input type="range" id="effectReverbDecay" min="0" max="0.95" step="0.01" value="0.5">
      </div>
    </div>

    <!-- Effects Output Control -->
    <div>
      <h3>Effects Output</h3>
      <div class="control-group">
        <label for="effectsOutputVolume">Effects Output Volume: <span id="effectsVolValue">0.80</span></label>
        <input type="range" id="effectsOutputVolume" min="0" max="1" step="0.01" value="0.8">
      </div>
    </div>
  </div>

  <template id="waveModuleTemplate">
    <div class="wave-module" data-id="__id__">
      <div class="wave-trigger">☰ Settings</div>
      <div class="external-output">
        <canvas class="output-canvas"></canvas>
        <div class="value output-value">0.000</div>
      </div>
      <div class="settings">
        <div class="control-group">
          <label>Type</label>
          <select class="wave-type">
            <option value="sine">Sine</option>
            <option value="square">Square</option>
            <option value="sawtooth">Sawtooth</option>
            <option value="reverse-sawtooth">Reverse Saw</option>
            <option value="triangle">Triangle</option>
            <option value="reverse-triangle">Reverse Triangle</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="control-group waveform-display-area"> 
          <label class="waveform-display-label">Waveform Shape</label> 
          <canvas class="draw-canvas" width="200" height="80" style="border:1px solid #444; background:#fff;"></canvas>
          <button class="clear-draw" style="font-size:12px;margin-top:4px; display:none;">Clear</button> 
        </div>
        <div class="control-group">
          <label>Speed (exp)</label>
          <input type="range" class="speed" min="-7" max="1" step="0.01" value="0">
          <div class="speed-display">1.0000000 Hz</div>
        </div>
        <div class="control-group speed-range-controls" style="/* Initially hide for modules 1-7 via JS if needed */">
          <label>Speed Min (log)</label>
          <input type="number" class="speed-min" value="-7" step="0.01">
          <label>Speed Max (log)</label>
          <input type="number" class="speed-max" value="1" step="0.01">
        </div>
        <div class="control-group">
          <label>Depth</label>
          <input type="range" class="depth" min="0" max="1" step="0.01" value="0.5">
          <div class="depth-display">0.50</div>
        </div>
        <div class="control-group">
          <label>Range</label>
          <input type="number" class="low" value="-1" step="any">
          <input type="number" class="high" value="1" step="any">
        </div>
        <div class="control-group">
          <label>Phase</label>
          <input type="range" class="phase" min="0" max="360" step="1" value="0">
          <div class="phase-display">0°</div>
        </div>
        <div class="control-group">
          <label>Log</label>
          <input type="range" class="log-scale" min="0.1" max="2" step="0.01" value="1">
          <div class="log-display">1.00</div>
        </div>
        <div class="control-group">
          <label>Enable</label>
          <input type="checkbox" class="enable">
        </div>
      </div>
    </div>
  </template>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const carrierOsc = audioCtx.createOscillator();
      const masterGain = audioCtx.createGain();
      const panner = audioCtx.createStereoPanner();
      // carrierOsc.connect(masterGain).connect(panner).connect(audioCtx.destination); // Old connection
      carrierOsc.connect(masterGain).connect(panner); // Connect synth output to panner
      carrierOsc.start();

      // --- BEGIN EFFECTS SECTION --- 
      const effectFilter = audioCtx.createBiquadFilter();
      const effectDryGain = audioCtx.createGain();
      const effectWetGain = audioCtx.createGain();
      const effectPreDelay = audioCtx.createDelay(1.0); // Max 1 second pre-delay
      const effectFeedback = audioCtx.createGain();
      const effectConvolver = audioCtx.createConvolver();
      const effectsFinalOutputVolume = audioCtx.createGain();

      // Connect panner output (main synth out) to the start of the effects chain
      panner.connect(effectFilter);

      // Generate impulse response for reverb
      function createIREffects(duration, decay) {
        const sr = audioCtx.sampleRate;
        const len = sr * duration;
        const buf = audioCtx.createBuffer(2, len, sr);
        for (let ch = 0; ch < 2; ch++) {
          const data = buf.getChannelData(ch);
          for (let i = 0; i < len; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decay);
          }
        }
        return buf;
      }
      effectConvolver.buffer = createIREffects(2, 2); // Default IR

      // Connect effects chain nodes
      effectFilter.connect(effectDryGain);          // Dry path
      effectFilter.connect(effectPreDelay);       // Wet path starts here
      effectPreDelay.connect(effectConvolver);
      effectConvolver.connect(effectFeedback);
      effectFeedback.connect(effectPreDelay);       // Feedback loop for plate reverb
      effectConvolver.connect(effectWetGain);       // Output from convolver to wet gain
      
      effectDryGain.connect(effectsFinalOutputVolume);
      effectWetGain.connect(effectsFinalOutputVolume);
      effectsFinalOutputVolume.connect(audioCtx.destination); // Final output of effects to destination

      // Helper for smooth parameter changes
      function smoothSetParam(param, value) { 
        if (param && typeof param.setTargetAtTime === 'function') {
            param.setTargetAtTime(value, audioCtx.currentTime, 0.01); 
        } else if (param && param.value !== undefined) {
            param.value = value; // For params that don't have setTargetAtTime (like delayTime on older APIs)
        }
      }
      // --- END EFFECTS SECTION --- 

      // Global controls
      document.getElementById('carrierType').addEventListener('change', e => { carrierOsc.type = e.target.value; });
      // document.getElementById('carrierFreq').addEventListener('input', e => { carrierOsc.frequency.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); }); // Managed in modulationLoop
      // document.getElementById('masterVol').addEventListener('input', e => { masterGain.gain.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); });   // Managed in modulationLoop
      document.getElementById('detune').addEventListener('input', e => { carrierOsc.detune.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); });
      document.getElementById('pan').addEventListener('input', e => { panner.pan.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); });

      const carrierFreqSlider = document.getElementById('carrierFreq');
      const carrierFreqDisplay = document.getElementById('carrierFreqDisplay');
      carrierFreqSlider.addEventListener('input', e => { carrierFreqDisplay.textContent = e.target.value; });

      const testSlider = document.getElementById('testSlider');
      const testSliderDisplay = document.getElementById('testSliderDisplay');
      testSlider.addEventListener('input', e => { testSliderDisplay.textContent = parseFloat(e.target.value).toFixed(2); });

      const test2Slider = document.getElementById('test2Slider');
      const test2SliderDisplay = document.getElementById('test2SliderDisplay');
      test2Slider.addEventListener('input', e => { test2SliderDisplay.textContent = parseFloat(e.target.value).toFixed(2); });

      // --- BEGIN EFFECTS PARAMETER CONTROL ---
      const effectElems = {};
      ['effectFilterType', 'effectFilterFrequency', 'effectFilterQ', 'effectFilterGain', 'effectReverbMix', 'effectReverbPreDelay', 'effectReverbDecay', 'effectsOutputVolume']
        .forEach(id => effectElems[id] = document.getElementById(id));
      ['effectFreqValue', 'effectQValue', 'effectGainValue', 'effectRevValue', 'effectPDValue', 'effectDecayValue', 'effectsVolValue']
        .forEach(id => effectElems[id] = document.getElementById(id));
      const effectFilterGainGroup = document.getElementById('effectFilterGainGroup');

      function updateEffectsParams() {
        if (!effectFilter || !audioCtx) return; // Ensure nodes are ready

        effectFilter.type = effectElems.effectFilterType.value;
        const frac = +effectElems.effectFilterFrequency.value / 100;
        const logMin = Math.log10(20), logMax = Math.log10(20000);
        const freq = Math.pow(10, logMin + (logMax - logMin) * frac);
        smoothSetParam(effectFilter.frequency, freq);
        smoothSetParam(effectFilter.Q, +effectElems.effectFilterQ.value);
        smoothSetParam(effectFilter.gain, +effectElems.effectFilterGain.value);
        effectElems.effectFreqValue.textContent = freq.toFixed(1);
        effectElems.effectQValue.textContent = (+effectElems.effectFilterQ.value).toFixed(2);
        effectElems.effectGainValue.textContent = effectElems.effectFilterGain.value;
        effectFilterGainGroup.style.display = ['lowshelf', 'highshelf', 'peaking'].includes(effectFilter.type) ? 'block' : 'none';

        // Reverb
        smoothSetParam(effectPreDelay.delayTime, +effectElems.effectReverbPreDelay.value / 1000);
        smoothSetParam(effectWetGain.gain, +effectElems.effectReverbMix.value);
        smoothSetParam(effectDryGain.gain, 1 - +effectElems.effectReverbMix.value);
        smoothSetParam(effectFeedback.gain, +effectElems.effectReverbDecay.value);
        effectElems.effectRevValue.textContent = (+effectElems.effectReverbMix.value).toFixed(2);
        effectElems.effectPDValue.textContent = effectElems.effectReverbPreDelay.value;
        effectElems.effectDecayValue.textContent = (+effectElems.effectReverbDecay.value).toFixed(2);

        // Effects Output Volume
        smoothSetParam(effectsFinalOutputVolume.gain, +effectElems.effectsOutputVolume.value);
        effectElems.effectsVolValue.textContent = (+effectElems.effectsOutputVolume.value).toFixed(2);
      }

      ['effectFilterType', 'effectFilterFrequency', 'effectFilterQ', 'effectFilterGain', 'effectReverbMix', 'effectReverbPreDelay', 'effectReverbDecay', 'effectsOutputVolume']
        .forEach(id => {
          if (effectElems[id]) {
            effectElems[id].addEventListener('input', updateEffectsParams);
          }
        });
      
      updateEffectsParams(); // Initial call to set parameters
      // --- END EFFECTS PARAMETER CONTROL ---

      // Create modules
      const container = document.getElementById('modulesContainer');
      const template = document.getElementById('waveModuleTemplate').innerHTML;
      const modules = [];
      for (let i = 0; i < 8; i++) {
        const html = template.replace(/__id__/g, i);
        container.insertAdjacentHTML('beforeend', html);
        modules.push(new WaveModule(container.children[i], audioCtx));
      }

      // Modulation loop
      function modulationLoop() {
        // Carrier Frequency: Controlled by global knob, additively modulated by modules[0]
        const carrierFreqKnobVal = parseFloat(document.getElementById('carrierFreq').value);
        let finalCarrierFreq = carrierFreqKnobVal; // Start with the knob value
        if (modules[0].isPlaying) {
            const freqModSignal = parseFloat(modules[0].outputValue.textContent);
            if (!isNaN(freqModSignal)) { // Check if output is a valid number
                finalCarrierFreq += freqModSignal; // Add module 0 output to the knob value
            }
        }
        carrierOsc.frequency.setValueAtTime(Math.max(1, finalCarrierFreq), audioCtx.currentTime); // Min 1Hz

        // Master Volume: Controlled by global knob, multiplicatively modulated by modules[1]
        const masterVolKnobVal = parseFloat(document.getElementById('masterVol').value);
        let finalMasterGainMultiplier = 1.0; // Default to no modulation on gain knob value
        if (modules[1].isPlaying) {
            const ampModSignal = parseFloat(modules[1].outputValue.textContent);
            if (!isNaN(ampModSignal)) {
                finalMasterGainMultiplier = ampModSignal;
            }
        }
        const targetMasterGain = Math.max(0, masterVolKnobVal * finalMasterGainMultiplier);
        // Smooth gain changes to prevent clicks
        masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime); // Cancel previous automations and set current value
        masterGain.gain.linearRampToValueAtTime(targetMasterGain, audioCtx.currentTime + 0.01); // Ramp to new target in 10ms

        // Module 2 output controls the global "Test" slider
        let targetTestSliderValue = parseFloat(document.getElementById('testSlider').value); // Keep current if module 2 is off
        if (modules[2].isPlaying) {
            const mod2Output = parseFloat(modules[2].outputValue.textContent);
            if (!isNaN(mod2Output)) {
                // Directly use module 2's output, clamped to Test slider's range
                targetTestSliderValue = Math.max(-7, Math.min(1, mod2Output)); 
            }
        }
        document.getElementById('testSlider').value = targetTestSliderValue;
        document.getElementById('testSliderDisplay').textContent = targetTestSliderValue.toFixed(2);
        
        // Module 0 Speed: "Test" slider (now driven by module 2) controls it, scaled by module 0's own speed min/max settings.
        const testSliderRawValue = targetTestSliderValue; // Use the value we just set for the Test slider
        const testSliderMinFixed = -7; // Fixed range of the global Test slider
        const testSliderMaxFixed = 1;  // Fixed range of the global Test slider

        // Normalize testSliderRawValue to a 0-1 range
        const normalizedTestValue = (testSliderRawValue - testSliderMinFixed) / (testSliderMaxFixed - testSliderMinFixed);

        let mod0MinLogSpeed = parseFloat(modules[0].prefs.speedMin.value);
        let mod0MaxLogSpeed = parseFloat(modules[0].prefs.speedMax.value);

        // Validate and set default for module 0's dynamic range if necessary
        if (isNaN(mod0MinLogSpeed) || isNaN(mod0MaxLogSpeed) || mod0MinLogSpeed >= mod0MaxLogSpeed) {
            mod0MinLogSpeed = -7; // Default min for module 0's effective range
            mod0MaxLogSpeed = 1;  // Default max for module 0's effective range
            // Optionally update the input fields if they were invalid
            modules[0].prefs.speedMin.value = mod0MinLogSpeed;
            modules[0].prefs.speedMax.value = mod0MaxLogSpeed;
        }

        // Update module 0's speed slider's actual min and max attributes
        modules[0].prefs.speed.min = mod0MinLogSpeed;
        modules[0].prefs.speed.max = mod0MaxLogSpeed;

        // Scale the normalizedTestValue to the new dynamic range of module 0's slider
        let targetMod0LogSpeed = mod0MinLogSpeed + (normalizedTestValue * (mod0MaxLogSpeed - mod0MinLogSpeed));
        
        // The step attribute of module 0's speed slider (modules[0].prefs.speed.step) remains 0.01 by default.
        // If the dynamic range (mod0MaxLogSpeed - mod0MinLogSpeed) becomes very small, the slider might feel coarse.
        // If it becomes very large, it might feel too fine. For now, 0.01 is kept.

        modules[0].setSpeed(targetMod0LogSpeed);

        // Module 3 output controls the global "Test2" slider (as before)
        let targetTest2SliderValue = parseFloat(document.getElementById('test2Slider').value); 
        if (modules[3].isPlaying) {
            const mod3Output = parseFloat(modules[3].outputValue.textContent);
            if (!isNaN(mod3Output)) {
                targetTest2SliderValue = Math.max(-7, Math.min(1, mod3Output)); 
            }
        }
        document.getElementById('test2Slider').value = targetTest2SliderValue;
        document.getElementById('test2SliderDisplay').textContent = targetTest2SliderValue.toFixed(2);

        // Module 1 Speed: "Test2" slider (driven by module 3) controls it, scaled by module 1's own speed min/max settings.
        const test2SliderRawValue = targetTest2SliderValue; // Value from Test2 slider (which is -7 to 1 log)
        const test2SliderMinFixed = -7; // Fixed range of the global Test2 slider
        const test2SliderMaxFixed = 1;  // Fixed range of the global Test2 slider

        // Normalize test2SliderRawValue to a 0-1 range
        const normalizedTest2Value = (test2SliderRawValue - test2SliderMinFixed) / (test2SliderMaxFixed - test2SliderMinFixed);

        let mod1MinLogSpeed = parseFloat(modules[1].prefs.speedMin.value);
        let mod1MaxLogSpeed = parseFloat(modules[1].prefs.speedMax.value);

        // Validate and set default for module 1's dynamic range if necessary
        if (isNaN(mod1MinLogSpeed) || isNaN(mod1MaxLogSpeed) || mod1MinLogSpeed >= mod1MaxLogSpeed) {
            mod1MinLogSpeed = -7; 
            mod1MaxLogSpeed = 1;  
            modules[1].prefs.speedMin.value = mod1MinLogSpeed;
            modules[1].prefs.speedMax.value = mod1MaxLogSpeed;
        }

        // Update module 1's speed slider's actual min and max attributes
        modules[1].prefs.speed.min = mod1MinLogSpeed;
        modules[1].prefs.speed.max = mod1MaxLogSpeed;

        // Scale the normalizedTest2Value to the new dynamic range of module 1's slider
        let targetMod1LogSpeed = mod1MinLogSpeed + (normalizedTest2Value * (mod1MaxLogSpeed - mod1MinLogSpeed));
        
        modules[1].setSpeed(targetMod1LogSpeed);

        requestAnimationFrame(modulationLoop);
      }
      modulationLoop();
      // Export settings as JSON
      document.getElementById('exportBtn').addEventListener('click', () => {
        const settings = {
          carrier: {
            type: document.getElementById('carrierType').value,
            freq: parseFloat(document.getElementById('carrierFreq').value),
            vol: parseFloat(document.getElementById('masterVol').value),
            detune: parseFloat(document.getElementById('detune').value),
            pan: parseFloat(document.getElementById('pan').value)
          },
          modules: modules.map(m => m.getSettings()),
          effects: {
            filterType: effectElems.effectFilterType.value,
            filterFrequency: effectElems.effectFilterFrequency.value, // Store raw slider value (0-100)
            filterQ: effectElems.effectFilterQ.value,
            filterGain: effectElems.effectFilterGain.value,
            reverbMix: effectElems.effectReverbMix.value,
            reverbPreDelay: effectElems.effectReverbPreDelay.value,
            reverbDecay: effectElems.effectReverbDecay.value,
            outputVolume: effectElems.effectsOutputVolume.value
          }
        };
        const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'wave-settings.json';
        a.click();
        URL.revokeObjectURL(url);
      });
      // Import settings
      document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
      document.getElementById('importFile').addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
          try {
            const settings = JSON.parse(ev.target.result);
            // Apply carrier settings
            const c = settings.carrier;
            if (c) {
              document.getElementById('carrierType').value = c.type;
              document.getElementById('carrierFreq').value = c.freq;
              document.getElementById('masterVol').value = c.vol;
              document.getElementById('detune').value = c.detune;
              document.getElementById('pan').value = c.pan;
              ['change','input'].forEach(evt=>document.getElementById('carrierType').dispatchEvent(new Event(evt)));
              ['input'].forEach(evt=>{
                ['carrierFreq','masterVol','detune','pan'].forEach(id=>document.getElementById(id).dispatchEvent(new Event(evt)));
              });
            }
            // Apply module settings
            if (Array.isArray(settings.modules)) {
              settings.modules.forEach((mod, idx) => {
                if (modules[idx] && typeof modules[idx].applySettings === 'function') {
                  modules[idx].applySettings(mod);
                }
              });
            }
            // Apply effects settings
            const fx = settings.effects;
            if (fx) {
              effectElems.effectFilterType.value = fx.filterType || 'lowpass';
              effectElems.effectFilterFrequency.value = fx.filterFrequency !== undefined ? fx.filterFrequency : 50;
              effectElems.effectFilterQ.value = fx.filterQ !== undefined ? fx.filterQ : 1;
              effectElems.effectFilterGain.value = fx.filterGain !== undefined ? fx.filterGain : 0;
              effectElems.effectReverbMix.value = fx.reverbMix !== undefined ? fx.reverbMix : 0.5;
              effectElems.effectReverbPreDelay.value = fx.reverbPreDelay !== undefined ? fx.reverbPreDelay : 20;
              effectElems.effectReverbDecay.value = fx.reverbDecay !== undefined ? fx.reverbDecay : 0.5;
              effectElems.effectsOutputVolume.value = fx.outputVolume !== undefined ? fx.outputVolume : 0.8;
              
              // Trigger input events to update displays and audio params via updateEffectsParams
              ['effectFilterType', 'effectFilterFrequency', 'effectFilterQ', 'effectFilterGain', 'effectReverbMix', 'effectReverbPreDelay', 'effectReverbDecay', 'effectsOutputVolume']
                .forEach(id => {
                  if (effectElems[id]) {
                      effectElems[id].dispatchEvent(new Event('input'));
                  }
              });
              // updateEffectsParams(); // Call directly after setting all values, or rely on dispatched events.
            }
          } catch (err) {
            console.error('Failed to import settings:', err);
          }
        };
        reader.readAsText(file);
      });
    });

    class WaveModule {
      constructor(root, audioCtx) {
        this.root = root;
        this.audioCtx = audioCtx;
        this.customPoints = [];
        this.history = [];
        this.isPlaying = false;
        this.startTime = 0;
        this.lastSpeed = 1;
        this.outputValue = root.querySelector('.output-value');
        this.outputCanvas = root.querySelector('.output-canvas'); this.outputCanvas.width = 200; this.outputCanvas.height = 50;
        this.outputCtx = this.outputCanvas.getContext('2d');
        this.trigger = root.querySelector('.wave-trigger');
        this.settings = root.querySelector('.settings');
        this.prefs = {
          waveType: root.querySelector('.wave-type'),
          waveformDisplayArea: root.querySelector('.waveform-display-area'),
          waveformDisplayLabel: root.querySelector('.waveform-display-label'),
          drawCanvas: root.querySelector('.draw-canvas'),
          drawCtx: root.querySelector('.draw-canvas') ? root.querySelector('.draw-canvas').getContext('2d') : null,
          clearDraw: root.querySelector('.clear-draw'),
          speed: root.querySelector('.speed'), speedDisplay: root.querySelector('.speed-display'),
          speedMin: root.querySelector('.speed-min'),
          speedMax: root.querySelector('.speed-max'),
          speedRangeControls: root.querySelector('.speed-range-controls'),
          depth: root.querySelector('.depth'), depthDisplay: root.querySelector('.depth-display'),
          low: root.querySelector('.low'), high: root.querySelector('.high'),
          phase: root.querySelector('.phase'), phaseDisplay: root.querySelector('.phase-display'),
          log: root.querySelector('.log-scale'), logDisplay: root.querySelector('.log-display'),
          enable: root.querySelector('.enable')
        };
        this.bind();
        if (this.root.dataset.id !== '0' && this.root.dataset.id !== '1' && this.prefs.speedRangeControls) {
            this.prefs.speedRangeControls.style.display = 'none';
        }
        this.updateDrawCanvasVisualization(); // Initial draw
      }

      bind() {
        const p = this.prefs;
        this.trigger.addEventListener('click', () => this.settings.style.display = this.settings.style.display === 'block' ? 'none' : 'block');
        p.enable.addEventListener('change', () => { this.isPlaying = p.enable.checked; this.audioCtx.resume(); if (this.isPlaying) { this.startTime = Date.now(); this.history = []; this.update(); }});
        
        p.waveType.addEventListener('change', () => {
            p.clearDraw.style.display = p.waveType.value === 'custom' ? 'inline-block' : 'none';
            this.updateDrawCanvasVisualization();
        });

        if (p.drawCanvas) {
          let drawing = false;
          p.drawCanvas.addEventListener('mousedown', e => { 
            if (p.waveType.value !=='custom') return;
            drawing=true; this.customPoints=[]; 
            this.updateDrawCanvasVisualization(); 
            const r=p.drawCanvas.getBoundingClientRect(); 
            const pt={x:e.clientX-r.left, y:e.clientY-r.top}; 
            this.customPoints.push(pt);
            p.drawCtx.beginPath();
            p.drawCtx.moveTo(pt.x, pt.y);
          });
          p.drawCanvas.addEventListener('mousemove', e => { 
            if (!drawing || p.waveType.value !=='custom') return; 
            const r=p.drawCanvas.getBoundingClientRect(); 
            const pt={x:e.clientX-r.left, y:e.clientY-r.top};
            this.customPoints.push(pt); 
            p.drawCtx.lineTo(pt.x,pt.y); 
            p.drawCtx.strokeStyle='#007bff';
            p.drawCtx.lineWidth=2; p.drawCtx.stroke(); 
          });
          p.drawCanvas.addEventListener('mouseup',() => {
            if (p.waveType.value === 'custom') drawing = false;
          });
          p.drawCanvas.addEventListener('mouseleave',()=> {
            if (p.waveType.value === 'custom') drawing = false;
          });
          p.clearDraw.addEventListener('click',()=>{
            if (p.waveType.value === 'custom') {
              this.customPoints=[];
              this.updateDrawCanvasVisualization();
            }
          });
        }
        p.speed.addEventListener('input', () => this.setSpeed(this.prefs.speed.value));
        p.depth.addEventListener('input',()=>p.depthDisplay.textContent=parseFloat(p.depth.value).toFixed(2));
        
        p.phase.addEventListener('input',()=>{
            p.phaseDisplay.textContent=p.phase.value+'°';
            this.updateDrawCanvasVisualization();
        });
        p.log.addEventListener('input',()=>{
            p.logDisplay.textContent=parseFloat(p.log.value).toFixed(2);
            this.updateDrawCanvasVisualization();
        });
      }

      updateDrawCanvasVisualization() {
        if (!this.prefs.drawCtx || !this.prefs.drawCanvas) return;
        const ctx = this.prefs.drawCtx;
        const canvas = this.prefs.drawCanvas;
        const type = this.prefs.waveType.value;
        const phaseDeg = parseFloat(this.prefs.phase.value);
        const logScale = parseFloat(this.prefs.log.value);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw center line
        ctx.beginPath();
        ctx.moveTo(0, canvas.height / 2);
        ctx.lineTo(canvas.width, canvas.height / 2);
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.stroke();

        if (type === 'custom') {
            this.redrawCustomWave();
        } else {
            this.drawStandardWave(type, phaseDeg * Math.PI / 180, logScale, ctx, canvas);
        }
      }

      redrawCustomWave() {
        if (!this.prefs.drawCtx || !this.prefs.drawCanvas || !this.customPoints) return;
        const ctx = this.prefs.drawCtx;
        // Clear and center line are handled by updateDrawCanvasVisualization before this is called
        // if (this.customPoints.length === 0) return; // No points to draw

        if (this.customPoints.length > 0) {
            ctx.beginPath();
            ctx.moveTo(this.customPoints[0].x, this.customPoints[0].y);
            for (let i = 1; i < this.customPoints.length; i++) {
                ctx.lineTo(this.customPoints[i].x, this.customPoints[i].y);
            }
            ctx.strokeStyle = '#61dafb';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
      }

      drawStandardWave(type, phaseRad, logScale, canvasCtx, canvas) {
        const width = canvas.width;
        const height = canvas.height;
        const midY = height / 2;
        const numPoints = width; // One point per horizontal pixel for smoothness

        canvasCtx.beginPath();
        canvasCtx.strokeStyle = '#61dafb';
        canvasCtx.lineWidth = 2;

        for (let i = 0; i < numPoints; i++) {
            let xNormalized = i / (numPoints -1); // Normalized x from 0 to 1
            
            // Apply log scale to the normalized x-coordinate (time axis)
            let tNormalized = xNormalized;
            if (logScale !== 1) {
                // Ensure positive base for pow, and handle edge cases if logScale makes it undefined
                if (tNormalized > 0) { 
                    tNormalized = Math.pow(tNormalized, logScale);
                } else if (logScale < 1 && tNormalized === 0) {
                     tNormalized = 0; // Avoid NaN for 0^positive
                } else if (logScale > 1 && tNormalized === 0) {
                     tNormalized = 0;
                }
                 // Clamp tNormalized to [0,1] after log operation if it goes out of bounds
                tNormalized = Math.max(0, Math.min(1, tNormalized));
            }

            const angle = (tNormalized * 2 * Math.PI) + phaseRad;
            let yValue = 0; // Waveform value from -1 to 1

            switch (type) {
                case 'sine': yValue = Math.sin(angle); break;
                case 'square': yValue = Math.sin(angle) >= 0 ? 0.8 : -0.8; break; // Keep amplitude for square
                case 'sawtooth': yValue = 2 * ( ( (angle / (2 * Math.PI)) % 1 + 1) % 1) - 1; break;
                case 'reverse-sawtooth': yValue = 1 - 2 * ( ( (angle / (2 * Math.PI)) % 1 + 1) % 1); break;
                case 'triangle': 
                    const triNormalized = ( ( (angle / (2*Math.PI)) % 1 + 1) % 1 );
                    yValue = triNormalized < 0.5 ? (4 * triNormalized - 1) : (-4 * triNormalized + 3); 
                    break;
                case 'reverse-triangle':
                    const rtriNormalized = ( ( (angle / (2*Math.PI)) % 1 + 1) % 1 );
                    yValue = rtriNormalized < 0.5 ? (1 - 4 * rtriNormalized) : (4 * rtriNormalized - 3);
                    break;
                default: yValue = 0;
            }
            
            const canvasY = midY - (yValue * midY * 0.9); // Scale to fit, 0.9 to avoid hitting exact top/bottom

            if (i === 0) {
                canvasCtx.moveTo(i, canvasY);
            } else {
                canvasCtx.lineTo(i, canvasY);
            }
        }
        canvasCtx.stroke();
      }

      setSpeed(newLogSpeed) {
        // Ensure newLogSpeed is a number
        newLogSpeed = parseFloat(newLogSpeed);
        if (isNaN(newLogSpeed)) return; // Safety check

        // Update the slider's visual position if it's not already there
        if (parseFloat(this.prefs.speed.value) !== newLogSpeed) {
            this.prefs.speed.value = newLogSpeed;
        }

        const newSpeedHz = Math.pow(10, newLogSpeed);
        const now = Date.now();

        // Phase correction logic
        // this.lastSpeed is the speed *before* this change
        // this.startTime is the startTime for the speed *before* this change
        const elapsedSinceLastStartTime = (now - this.startTime) / 1000;
        const currentPhaseProgress = (elapsedSinceLastStartTime * this.lastSpeed) % 1;

        this.lastSpeed = newSpeedHz; // Update to the new speed in Hz
        // Adjust startTime for phase continuity: startTime = now - time_into_new_cycle
        // time_into_new_cycle = currentPhaseProgress / newSpeedHz (if currentPhaseProgress is in cycles)
        this.startTime = now - (currentPhaseProgress / newSpeedHz) * 1000;
        if (newSpeedHz === 0) { // Avoid division by zero if speed is set to effectively zero
            this.startTime = now; 
        }

        this.prefs.speedDisplay.textContent = newSpeedHz.toFixed(7) + ' Hz';
      }
      calculate(t) {
        const p=this.prefs,dep=parseFloat(p.depth.value);
        let raw=t,logS=parseFloat(p.log.value);
        raw=logS===1?raw:(Math.log(raw*(logS-1)+1)/Math.log(logS));
        const phase=(raw*2*Math.PI+parseFloat(p.phase.value)*Math.PI/180);
        let v=0;
        switch(p.waveType.value){
          case 'sine': v=Math.sin(phase);break;
          case 'square': v=Math.sign(Math.sin(phase));break;
          case 'sawtooth': v=2*(raw-0.5);break;
          case 'reverse-sawtooth': v=2*(0.5-raw);break;
          case 'triangle': v=2*Math.abs(2*(raw-0.5))-1;break;
          case 'reverse-triangle': v=1-2*Math.abs(2*(raw-0.5));break;
          case 'custom': if(this.customPoints.length>1){const pts=this.customPoints, idx=raw*(pts.length-1),i=Math.floor(idx),ni=(i+1)%pts.length,f=idx-i; const y=pts[i].y*(1-f)+pts[ni].y*f; v=1-2*(y/this.prefs.drawCanvas.height);}break;
        }
        return v*dep;
      }
      update(){ if(!this.isPlaying) return; const t=((Date.now()-this.startTime)/1000*this.lastSpeed)%1; const val=this.calculate(t); const low=parseFloat(this.prefs.low.value),high=parseFloat(this.prefs.high.value); const sc=low+(val+1)*(high-low)/2; this.outputValue.textContent=sc.toFixed(3); this.history.push(sc); if(this.history.length>this.outputCanvas.width) this.history.shift(); const c=this.outputCtx; c.fillStyle='#282c34';c.fillRect(0,0,this.outputCanvas.width,this.outputCanvas.height); c.beginPath();c.strokeStyle='#61dafb';c.lineWidth=2; this.history.forEach((v,i)=>{const y=this.outputCanvas.height-((v-low)/(high-low))*this.outputCanvas.height; i===0?c.moveTo(i,y):c.lineTo(i,y);});c.stroke(); requestAnimationFrame(()=>this.update()); }
      getSettings() {
        const p = this.prefs;
        return {
          id: this.root.dataset.id,
          waveType: p.waveType.value,
          customPoints: this.customPoints,
          speed: parseFloat(p.speed.value),
          speedMin: p.speedMin ? parseFloat(p.speedMin.value) : -7,
          speedMax: p.speedMax ? parseFloat(p.speedMax.value) : 1,
          depth: parseFloat(p.depth.value),
          low: parseFloat(p.low.value),
          high: parseFloat(p.high.value),
          phase: parseInt(p.phase.value),
          logScale: parseFloat(p.log.value),
          enabled: p.enable.checked
        };
      }
      applySettings(s) {
        if (!s) return;
        const p = this.prefs;

        p.waveType.value = s.waveType || 'sine';
        this.customPoints = s.customPoints || [];
        p.clearDraw.style.display = p.waveType.value === 'custom' ? 'inline-block' : 'none';

        if (p.speedMin) {
            p.speedMin.value = s.speedMin !== undefined ? s.speedMin : -7;
        }
        if (p.speedMax) {
            p.speedMax.value = s.speedMax !== undefined ? s.speedMax : 1;
        }

        p.depth.value = s.depth !== undefined ? s.depth : 0.5;
        p.depthDisplay.textContent = parseFloat(p.depth.value).toFixed(2);

        p.low.value = s.low !== undefined ? s.low : -1;
        p.high.value = s.high !== undefined ? s.high : 1;

        p.phase.value = s.phase !== undefined ? s.phase : 0;
        p.phaseDisplay.textContent = p.phase.value + '°';

        p.log.value = s.logScale !== undefined ? s.logScale : 1;
        p.logDisplay.textContent = parseFloat(p.log.value).toFixed(2);
        
        p.enable.checked = s.enabled || false;
        this.isPlaying = p.enable.checked;
        if (this.isPlaying) {
            this.startTime = Date.now(); 
            this.history = [];
            this.update(); 
        } else {
            this.outputValue.textContent = (0).toFixed(3);
            const c = this.outputCtx;
            c.fillStyle = '#282c34';
            c.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
        }
        this.updateDrawCanvasVisualization(); // Update visualization after all settings applied
      }
    }
  </script>
</body>
</html>

